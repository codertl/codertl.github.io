<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>web前端面试题</title>
    <url>/2022/02/18/interview/</url>
    <content><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h3 id="一-JavaScript"><a href="#一-JavaScript" class="headerlink" title="一.JavaScript"></a>一.JavaScript</h3><h4 id="1-foreach-如何跳出循环"><a href="#1-foreach-如何跳出循环" class="headerlink" title="1. foreach 如何跳出循环?"></a>1. foreach 如何跳出循环?</h4><p>例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">message</span> != <span class="string">&quot;error&quot;</span>) <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100</span>); <span class="comment">// 结果 1,2,3,100</span></span><br></pre></td></tr></table></figure>

<h4 id="2-箭头函数的-this-指向？为什么箭头函数没有自己的-this？"><a href="#2-箭头函数的-this-指向？为什么箭头函数没有自己的-this？" class="headerlink" title="2.箭头函数的 this 指向？为什么箭头函数没有自己的 this？"></a>2.箭头函数的 this 指向？为什么箭头函数没有自己的 this？</h4><p>箭头函数的 this 指向是上级作用域的 this，如果上级也没有 this，会继续往上找。</p>
<p>箭头函数没有 prototype(原型)，所有箭头函数本身没有 this。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript笔记</title>
    <url>/2022/03/24/typescript%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="TypeScript-学习"><a href="#TypeScript-学习" class="headerlink" title="TypeScript 学习"></a>TypeScript 学习</h1><h2 id="一、TypeScript-介绍"><a href="#一、TypeScript-介绍" class="headerlink" title="一、TypeScript 介绍"></a>一、TypeScript 介绍</h2><h3 id="什么是-TypeScript？"><a href="#什么是-TypeScript？" class="headerlink" title="什么是 TypeScript？"></a>什么是 TypeScript？</h3><ul>
<li>TypeScript 简称 TS</li>
<li>TS 和 JS 之间的关系其实就是 Less&#x2F;Sass 和 CSS 之间的关系</li>
<li>就像 Less&#x2F;Sass 是对 CSS 进行扩展一样, TS 也是对 JS 进行扩展</li>
<li>就像 Less&#x2F;Sass 最终会转换成 CSS 一样, 我们编写好的 TS 代码最终也会换成 JS</li>
<li>TypeScript 是 JavaScript 的超集，因为它扩展了 JavaScript，有 JavaScript 没有的东西。</li>
<li>硬要以父子类关系来说的话，TypeScript 是 JavaScript 子类，继承的基础上去扩展。</li>
</ul>
<h3 id="为什么需要-TypeScript？"><a href="#为什么需要-TypeScript？" class="headerlink" title="为什么需要 TypeScript？"></a>为什么需要 TypeScript？</h3><ul>
<li>简单来说就是因为 JavaScript 是弱类型, 很多错误只有在运行时才会被发现</li>
<li>而 TypeScript 提供了一套静态检测机制, 可以帮助我们在编译时就发现错误</li>
</ul>
<h3 id="TypeScript-的特点？"><a href="#TypeScript-的特点？" class="headerlink" title="TypeScript 的特点？"></a>TypeScript 的特点？</h3><ul>
<li>支持最新的 JavaScript 新特特性</li>
<li>支持代码静态检查</li>
<li>支持诸如 C,C++,Java,Go 等后端语言中的特性 (枚举、泛型、类型转换、命名空间、声明文件、类、接口等)</li>
</ul>
<h2 id="二、TypeScript-的安装"><a href="#二、TypeScript-的安装" class="headerlink" title="二、TypeScript 的安装"></a>二、TypeScript 的安装</h2><p><strong>安装命令</strong></p>
<p><code>npm install typescript -g</code></p>
<p><strong>查看版本</strong></p>
<p><code>tsc --version</code></p>
<h2 id="三、执行-TypeScript-两种方式"><a href="#三、执行-TypeScript-两种方式" class="headerlink" title="三、执行 TypeScript 两种方式"></a>三、执行 TypeScript 两种方式</h2><h3 id="方式一：通过-ts-node-库"><a href="#方式一：通过-ts-node-库" class="headerlink" title="方式一：通过 ts-node 库"></a>方式一：通过 ts-node 库</h3><p><strong>通过 ts-node 库，为 TypeScript 运行提供执行环境</strong></p>
<p><strong>TS 的执行环境</strong></p>
<p><code>npm install ts-node -g</code></p>
<p>ts-node 是一个执行环境，把 TS 变成 JS 然后执行</p>
<p><strong>ts-node 需要依赖 tslib 和 @types&#x2F;node 两个包</strong></p>
<p><code>npm install tslib @types/node -g</code></p>
<h3 id="方式二：通过-Webpack-的本地服务"><a href="#方式二：通过-Webpack-的本地服务" class="headerlink" title="方式二：通过 Webpack 的本地服务"></a>方式二：通过 Webpack 的本地服务</h3><p><strong>通过 webpack，配置本地的 TypeScript 编译环境和开启一个本地服务，可以直接运行在浏览器上；</strong></p>
<p>1.生成 package.json 文件</p>
<p>$ <code> npm init -y</code></p>
<p>2.安装 wepack 和 webpack-cli</p>
<p>$<code>npm install webpack webpack-cli -D</code> 局部安装</p>
<p>3.创建 webpack.config.js</p>
<p>4.安装 ts-loader 和 typescript</p>
<p>$<code>npm install ts-loader typescript -D</code></p>
<p>5.安装 devServer</p>
<p>$<code>npm install webpack-dev-server -D</code></p>
<p>6.生成 tsconfig 配置文件</p>
<p>$<code>tsc -init</code></p>
<p>7.安装 HtmlWebpackPlugin 插件</p>
<p>该插件会生成一个 HTML5 文件</p>
<p>$<code>npm install html-webpack-plugin -D</code></p>
<p>8.配置 WebpackConfig 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.ts&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;...&quot;</span>], <span class="comment">// ...访问默认扩展名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>9.在 package.json 文件里添加项目打包命令和运行命令</p>
<p><a href="https://imgtu.com/i/qG0gMD"><img src="https://s1.ax1x.com/2022/03/24/qG0gMD.png" alt="qG0gMD.png"></a></p>
<p>10.打包项目和运行项目</p>
<p>打包 $<code>npm run build</code></p>
<p>运行 $<code>npm run serve</code></p>
<p><strong>项目结构</strong></p>
<p><a href="https://imgtu.com/i/qGBKSK"><img src="https://s1.ax1x.com/2022/03/24/qGBKSK.png" alt="qGBKSK.png"></a></p>
<h2 id="四、变量的定义格式"><a href="#四、变量的定义格式" class="headerlink" title="四、变量的定义格式"></a>四、变量的定义格式</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul>
<li>在 TypeScript 中定义变量需要指定 标识符 的类型。</li>
<li>所以完整的声明格式如下：<ul>
<li>声明了类型后 TypeScript 就会进行类型检测，声明的类型可以称之为<span style="color:red;">类型注解</span>；</li>
<li><code>var/let/const 标识符: 数据类型 = 赋值;</code></li>
</ul>
</li>
<li>比如我们声明一个 message，完整的写法如下：<ul>
<li>注意：这里的 string 是小写的，和 String 是有区别的</li>
<li>string 是 TypeScript 中定义的字符串类型，String 是 ECMAScript 中定义的一个类</li>
<li><code>let message:string = &#39;Hello World&#39;;</code></li>
</ul>
</li>
<li>如果我们给 message 赋值其他类型的值，那么就会报错：</li>
</ul>
<h3 id="声明变量的关键字"><a href="#声明变量的关键字" class="headerlink" title="声明变量的关键字"></a>声明变量的关键字</h3><ul>
<li>在 TypeScript 定义变量（标识符）和 ES6 之后一致，可以使用 var、let、const 来定义。<br><a href="https://imgtu.com/i/qGBxne"><img src="https://s1.ax1x.com/2022/03/24/qGBxne.png" alt="qGBxne.png"></a></li>
<li>当然，在 tslint 中并不推荐使用 var 来声明变量：<ul>
<li>可见，在 TypeScript 中并不建议再使用 var 关键字了，主要原因和 ES6 升级后 let 和 var 的区别是一样的，var 是没 有块级作用域的，会引起很多的问题。</li>
</ul>
</li>
</ul>
<h3 id="变量的推导（推断）"><a href="#变量的推导（推断）" class="headerlink" title="变量的推导（推断）"></a>变量的推导（推断）</h3><p>在开发中，有时候为了方便起见我们并不会在声明每一个变量时都写上对应的数据类型，我们更希望可以通过 TypeScript 本身的 特性帮助我们推断出对应的变量类型：</p>
<p><a href="https://imgtu.com/i/qGDCtI"><img src="https://s1.ax1x.com/2022/03/24/qGDCtI.png" alt="qGDCtI.png"></a></p>
<p>如果给 foo 重新赋值 123</p>
<p><a href="https://imgtu.com/i/qGDPht"><img src="https://s1.ax1x.com/2022/03/24/qGDPht.png" alt="qGDPht.png"></a></p>
<ul>
<li>这是因为在一个变量第一次赋值时，会根据后面的赋值内容的类型，来推断出变量的类型：<ul>
<li>上面的 foo 就是因为后面赋值的是一个 string 类型，所以 foo 虽然没有明确的说明，但是依然是一个 string 类型；</li>
</ul>
</li>
</ul>
<h2 id="五、JavaScript-和-TypeScript-的数据类型"><a href="#五、JavaScript-和-TypeScript-的数据类型" class="headerlink" title="五、JavaScript 和 TypeScript 的数据类型"></a>五、JavaScript 和 TypeScript 的数据类型</h2><p>我们经常说 TypeScript 是 JavaScript 的超集</p>
<p><a href="https://imgtu.com/i/qGDtHJ"><img src="https://s1.ax1x.com/2022/03/24/qGDtHJ.png" alt="qGDtHJ.png"></a></p>
<h3 id="number-类型"><a href="#number-类型" class="headerlink" title="number 类型"></a>number 类型</h3><p><strong>数字类型是我们开发中经常使用的类型，TypeScript 和 JavaScript 一样，不区分整数类型（int）和浮点型 （double），统一为 number 类型。</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num1</span>: <span class="built_in">number</span> = <span class="number">66</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num2</span>: <span class="built_in">number</span> = <span class="number">12.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 也支持二进制，八进制，十六进制的表示方式</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="number">100</span>; <span class="comment">//十进制</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="number">0b1001</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="number">0o147</span>; <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="number">0x18af</span>; <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>

<h3 id="boolean-类型"><a href="#boolean-类型" class="headerlink" title="boolean 类型"></a>boolean 类型</h3><p><strong>boolean 类型只有两个取值：true 和 false，非常简单</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">flag = <span class="number">60</span> &lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3><p><strong>string 类型是字符串类型，可以使用单引号或双引号</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样也支持ES6的模板字符串来拼接变量和字符串</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> height = <span class="number">1.88</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span> age is <span class="subst">$&#123;age&#125;</span> height is <span class="subst">$&#123;height&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h3><p><strong>数组的定义方式有两种</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="built_in">string</span>[] = [<span class="string">&quot;James&quot;</span>, <span class="string">&quot;kobe&quot;</span>, <span class="string">&quot;ldh&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">info2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;James&quot;</span>, <span class="string">&quot;kobe&quot;</span>, <span class="string">&quot;ldh&quot;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a>object 类型</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果手动给对象添加类型注解的话会获取不到里面的值</span></span><br><span class="line"><span class="comment">// 推荐让TypeScript自动推导</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title1 = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> title2 = <span class="title class_">Symbol</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [title1]: <span class="string">&quot;程序员&quot;</span>,</span><br><span class="line">  [title2]: <span class="string">&quot;律师&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info[title1]);</span><br></pre></td></tr></table></figure>

<h3 id="null-和-undefined-类型"><a href="#null-和-undefined-类型" class="headerlink" title="null 和 undefined 类型"></a>null 和 undefined 类型</h3><p><strong>在 JavaScript 中，undefined 和 null 是两个基本数据类型。 n 在 TypeScript 中，它们各自的类型也是 undefined 和 null，也就意味着它们既是实际的值，也是自己的类型：</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">n1</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n2</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h3><ul>
<li>在某些情况下，我们确实无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用 any 类型。</li>
<li>any 类型有点像一种讨巧的 TypeScript 手段：<ul>
<li>我们可以对 any 类型的变量进行任何的操作，包括获取不存在的属性、方法；</li>
<li>我们给一个 any 类型的变量赋值任何的值，比如数字、字符串的值；</li>
</ul>
</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 TypeScript 中，任何类型都归为any类型，这让 any 类型成为了类型系统的顶级类型。</span></span><br><span class="line"><span class="comment">// 如果是一个普通的类型，在赋值过程中改变类型是不被允许的，但如果是 any 类型，则允许赋值为任意类型</span></span><br><span class="line"><span class="comment">// 在 any 上访问任何属性都是允许的,也允许调用任何方法.</span></span><br><span class="line"><span class="comment">// 在不想给某些JavaScript 添加具体的数据类型时可以使用 any 类型(原生JavaScript代码是一样)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">any</span> = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">message = <span class="number">123</span>;</span><br><span class="line">message = <span class="literal">true</span>;</span><br><span class="line">message = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="unknown-类型"><a href="#unknown-类型" class="headerlink" title="unknown 类型"></a>unknown 类型</h3><p>就像所有类型都可以赋值给 <code>any</code>，所有类型也都可以赋值给 <code>unknown</code>。这使得 <code>unknown</code> 成为 TypeScript 类型系统的另一种顶级类型（另一种是 <code>any</code>）。下面我们来看一下 <code>unknown</code> 类型的使</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unknown类型只能赋值给 any 和 unknown类型</span></span><br><span class="line"><span class="comment">// any类型可以赋值给任意类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">result</span>: unknown;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  result = <span class="title function_">foo</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">res</span>: unknown = result; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">res2</span>: <span class="built_in">any</span> = result; <span class="comment">//ok</span></span><br><span class="line"><span class="comment">// let message: string = result; //Error</span></span><br><span class="line"><span class="comment">// let num: number = result; //Error</span></span><br></pre></td></tr></table></figure>

<h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。<br>当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">30</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h3><p>never 表示永远不会发生值的类型，比如一个函数：<br>如果一个函数中是一个死循环或者抛出一个异常，那么这个函数会返回东西吗？<br>不会，那么写 void 类型或者其他类型作为返回值类型都不合适，我们就可以使用 never 类型；</p>
<p><strong>下面一个例子让我们认识 never 类型的应用场景</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">message: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> message) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;string处理方式处理message&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;number处理方式处理message&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">check</span>: <span class="built_in">never</span> = message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">handleMessage</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>注意在 case 分支里面，我们把收窄为 never 的 message 赋值给一个显示声明的 never 变量。<br>如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 message 的类型：<br>然而他忘记同时修改 handleMessage 方法中的控制流程，<br>这时候 default 分支的 message 类型会被收窄为 boolean 类型，<br>导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，<br>我们可以确保 handleMessage 方法总是穷尽了 Foo 的所有可能类型。<br>通过这个示例，我们可以得出一个结论：使用 never 避免出现新增了联合类型没有对应的实现，<br>目的就是写出类型绝对安全的代码。</p>
<h3 id="tuble-类型"><a href="#tuble-类型" class="headerlink" title="tuble 类型"></a>tuble 类型</h3><p><strong>tuble 是元组类型，数组和元组有什么区别呢？</strong><br>数组中通常建议存放相同类型的元素，不同类型的元素是不推荐存放在数组的(可以存放在对象或者元组中)<br>其次，元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="string">&quot;giao&quot;</span>, <span class="number">18</span>, <span class="number">1.88</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = arr[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br></pre></td></tr></table></figure>

<p><strong>元组的应用场景</strong></p>
<p>那么 tuple 在什么地方使用的是最多的呢？<br>tuple 通常可以作为返回的值，在使用的时候会非常的方便；</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> useState&lt;T&gt;(<span class="attr">state</span>: T): [T, <span class="function">(<span class="params">newState: T</span>) =&gt;</span> <span class="built_in">void</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = state;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeState</span> = (<span class="params">newState: T</span>) =&gt; &#123;</span><br><span class="line">    currentState = newState;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> [currentState, changeState];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [counter, setcounter] = <span class="title function_">useState</span>(<span class="number">666</span>);</span><br><span class="line"><span class="title function_">setcounter</span>(<span class="number">666</span>);</span><br></pre></td></tr></table></figure>

<h2 id="六、-TypeScript-的类型补充"><a href="#六、-TypeScript-的类型补充" class="headerlink" title="六、 TypeScript 的类型补充"></a>六、 TypeScript 的类型补充</h2><h3 id="函数的参数和返回值类型"><a href="#函数的参数和返回值类型" class="headerlink" title="函数的参数和返回值类型"></a>函数的参数和返回值类型</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给参数加类型注解：num1: number,num2: number;</span></span><br><span class="line"><span class="comment">// 给返回值添加类型注解：(): number</span></span><br><span class="line"><span class="comment">// 在开发中，通常情况下可以不写返回值的类型注解(自动推导)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// ok</span></span><br><span class="line"><span class="comment">//sum(&#x27;aaa&#x27;, &#x27;bbb&#x27;) // Error</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="匿名函数的参数"><a href="#匿名函数的参数" class="headerlink" title="匿名函数的参数"></a>匿名函数的参数</h3><ul>
<li>匿名函数与函数声明会有一些不同：<ul>
<li>当一个函数出现在 TypeScript 可以确定该函数会被如何调用的地方时；</li>
<li>该函数的参数会自动指定类型；</li>
</ul>
</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通常情况下，在定义一个函数时，都会给参数添加类型注解</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;why&quot;</span>, <span class="string">&quot;kobe&quot;</span>, <span class="string">&quot;james&quot;</span>];</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>我们并没有指定 item 的类型，但是 item 是一个 string 类型：<ul>
<li>这是因为 TypeScript 会根据 forEach 函数的类型以及数组的类型推断出 item 的类型；</li>
<li>这个过程称之为上下文类型（contextual typing），因为函数执行的上下文可以帮助确定参数和返回值的类型；</li>
</ul>
</li>
</ul>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>如果我们希望限定一个函数接受的参数是一个对象，这个时候要如何限定呢？<br>我们可以使用对象类型；</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Point: x/y -&gt;对象类型</span></span><br><span class="line"><span class="comment">// 对象类型可以用分号(;)分割也可以用逗号(,)分割</span></span><br><span class="line"><span class="comment">// &#123;x:number;y:number&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printPoint</span>(&#123; <span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">321</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在这里我们使用了一个对象来作为类型：<br>在对象我们可以添加属性，并且告知 TypeScript 该属性需要是什么类型, 属性之间可以使用<code> ,</code> 或者<code>;</code>来分割，最后一个分隔符是可选的； 每个属性的类型部分也是可选的，如果不指定，那么就是 any 类型；</p>
<h3 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h3><p>在参数后面添加<code>?:</code> 声明的类型注解是可选类型</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Point: x/y/z -&gt;对象类型</span></span><br><span class="line"><span class="comment">// 对象类型可以用分号(;)分割也可以用逗号(,)分割</span></span><br><span class="line"><span class="comment">// &#123;x:number;y:number,z?:number&#125;</span></span><br><span class="line"><span class="comment">// ?: 声明的类型注解是可选类型</span></span><br><span class="line"><span class="comment">// 如果可选类型没有传值的话默认是 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span>; z?: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">x</span>); <span class="comment">// 123</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">y</span>); <span class="comment">// 321</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(point.<span class="property">z</span>); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printPoint</span>(&#123; <span class="attr">x</span>: <span class="number">123</span>, <span class="attr">y</span>: <span class="number">321</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number |string 联合类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">//使用联合类型的值时，需要特别小心</span></span><br><span class="line">  <span class="comment">// narrow：缩小</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你的id是：&quot;</span> + id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printID</span>(<span class="number">15</span>);</span><br><span class="line"><span class="title function_">printID</span>(<span class="string">&quot;dfd&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="可选类型和联合类型的关系"><a href="#可选类型和联合类型的关系" class="headerlink" title="可选类型和联合类型的关系"></a>可选类型和联合类型的关系</h3><p>可选类型可以看做是 类型 和 undefined 的联合类型：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个参数是一个可选类型的时候，它其实类似于是 类型|undefined 的联合类型</span></span><br><span class="line"><span class="comment">// function print(message?: string) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(message)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// print()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">message: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>

<h3 id="类型的别名"><a href="#类型的别名" class="headerlink" title="类型的别名"></a>类型的别名</h3><p>前面我们通过在类型注解中编写 对象类型 和 联合类型，但是当我们想要多次在其他地方使用时，就要编写多次。<br>比如我们可以给对象类型起一个别名：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type: 用于定义类型别名(type alias)</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IDtype</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">123</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="number">321</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDtype</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: Point</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有时候 TypeScript 无法获取具体的类型信息，这个我们需要使用类型断言（Type Assertions）。<br>比如我们通过 document.getElementById，TypeScript 只知道该函数会返回 HTMLElement ，但并不知道它 具体的类型</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型断言 as</span></span><br><span class="line"><span class="comment">// TypeScript只允许类型断言转换为 更具体 或者 不太具体 的类型，此规则可防止不可能的强制转换：</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;haha&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span>;</span><br><span class="line">el.<span class="property">src</span> = <span class="string">&quot;url地址&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="非空类型断言"><a href="#非空类型断言" class="headerlink" title="非空类型断言"></a>非空类型断言</h3><p>当我们编写下面的代码时，在执行 ts 的编译阶段会报错：<br>这是因为传入的 message 有可能是为 undefined 的，这个时候是不能执行方法的；</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pringMessageLength</span>(<span class="params">message?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">pringMessageLength</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果我们确定传入的参数是有值，这个时候我们可以使用非空类型断言<br>非空类型断言使用是(!),表示可以确定某个标识符是有值的，跳过 ts 在编译阶段对它的检测；</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pringMessageLength</span>(<span class="params">message?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message?.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">pringMessageLength</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="可选链的使用"><a href="#可选链的使用" class="headerlink" title="可选链的使用"></a>可选链的使用</h3><p>可选链事实上并不是 TypeScript 独有的特性，它是 ES11（ES2020）中增加的特性.<br>可选链使用可选链操作符 <code>?.</code><br>它的作用是当对象的属性不存在时，会短路，直接返回 undefined，如果存在，那么才会继续执行</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  friend?: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    girlFrend?: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">friend</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;james&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不加可选操作符</span></span><br><span class="line"><span class="comment">// console.log(info.name) // why</span></span><br><span class="line"><span class="comment">// console.log(info.friend.name) // Error</span></span><br><span class="line"><span class="comment">// 如果没有值</span></span><br><span class="line"><span class="comment">// console.log(info.friend.girlFrend.name) // Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加可选操作符</span></span><br><span class="line"><span class="comment">// console.log(info.friend?.name)  // james</span></span><br><span class="line"><span class="comment">// console.log(info.friend?.girlFrend?.name) // 古力娜扎</span></span><br><span class="line"><span class="comment">// 如果没有值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>?.<span class="property">girlFrend</span>?.<span class="property">name</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="操作符"><a href="#操作符" class="headerlink" title="(!!) 操作符"></a>(!!) 操作符</h3><p>将一个其他类型转换成 Boolean 类型，类似于 Boolean(变量)的方式</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// !! 将一个其他类型转换成Boolean类型，类似于Boolean(变量)的方式</span></span><br><span class="line"><span class="keyword">let</span> flag = !!message;</span><br><span class="line"><span class="comment">// let flag = Boolean(message)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flag);</span><br></pre></td></tr></table></figure>

<h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title="(??) 操作符"></a>(??) 操作符</h3><p>空值合并操作符（??）是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数， 否则返回左侧操作数。</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 和下方三元运算符同等效果</span></span><br><span class="line"><span class="keyword">const</span> content = message ?? <span class="string">&quot;你好啊，张三&quot;</span>;</span><br><span class="line"><span class="comment">// const content = message ? message : &#x27;你好啊，张三&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(content);</span><br></pre></td></tr></table></figure>

<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>字面量类型 (literal types)</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="string">&quot;Hello World&quot;</span> = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>字面量类型的意义，就是必须结合联合类型</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Alignment</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;center&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">align</span>: <span class="title class_">Alignment</span> = <span class="string">&quot;left&quot;</span>;</span><br><span class="line">align = <span class="string">&quot;center&quot;</span>; <span class="comment">// ok</span></span><br><span class="line">align = <span class="string">&quot;right&quot;</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// align = &#x27;hahah&#x27; // Error</span></span><br></pre></td></tr></table></figure>

<p><strong>字面量推理</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const info = &#123;</span></span><br><span class="line"><span class="comment">//   url: &#x27;http://www.baidu.com&#x27;,</span></span><br><span class="line"><span class="comment">//   method: &#x27;POST&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function request(url: string, method: &#x27;GET&#x27; | &#x27;POST&#x27;) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// request(info.url, info.method) // Error 原因是string类型不可以赋值给字面量类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Method</span> = <span class="string">&quot;GET&quot;</span> | <span class="string">&quot;POST&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Request</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">method</span>: <span class="title class_">Method</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">Request</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url: <span class="built_in">string</span>, method: Method</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">request</span>(info.<span class="property">url</span>, info.<span class="property">method</span>); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="类型缩（类型守卫）"><a href="#类型缩（类型守卫）" class="headerlink" title="类型缩（类型守卫）"></a>类型缩（类型守卫）</h3><p>什么是类型缩小呢？</p>
<ul>
<li>类型缩小的英文是 Type Narrowing；</li>
<li>我们可以通过类似于 typeof padding &#x3D;&#x3D;&#x3D; “number” 的判断语句，来改变 TypeScript 的执行路径；</li>
<li>在给定的执行路径中，我们可以缩小比声明时更小的类型，这个过程称之为 缩小;</li>
<li>而我们编写的 typeof padding &#x3D;&#x3D;&#x3D; “number 可以称之为 类型保护（type guards）</li>
</ul>
<p>常见的类型保护有如下几种：</p>
<ul>
<li>typeof</li>
<li>平等缩小（比如&#x3D;&#x3D;&#x3D;、!&#x3D;&#x3D;）</li>
<li>instanceof</li>
<li>in</li>
<li>等等…</li>
</ul>
<p><strong>typeof</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. typeof缩小</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IDType</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printID</span>(<span class="params">id: IDType</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>平等缩小</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 平等缩小 (===,==,!==,!=,switch)</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;center&quot;</span> | <span class="string">&quot;right&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printDirection</span>(<span class="params">direction: Direction</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. if 判断</span></span><br><span class="line">  <span class="keyword">if</span> (direction === <span class="string">&quot;left&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(direction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction === <span class="string">&quot;center&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(direction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(direction);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. switch 判断</span></span><br><span class="line">  <span class="comment">// switch (direction) &#123;</span></span><br><span class="line">  <span class="comment">//   case &#x27;left&#x27;:</span></span><br><span class="line">  <span class="comment">//     console.log(direction);</span></span><br><span class="line">  <span class="comment">//     break;</span></span><br><span class="line">  <span class="comment">//   case &#x27;center&#x27;:</span></span><br><span class="line">  <span class="comment">//     console.log(direction);</span></span><br><span class="line">  <span class="comment">//     break;</span></span><br><span class="line">  <span class="comment">//   default:</span></span><br><span class="line">  <span class="comment">//     console.log(direction);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>instanceof</strong></p>
<p>JavaScript 有一个运算符来检查一个值是否是另一个值的“实例”</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. instanceof</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printTime</span>(<span class="params">time: <span class="built_in">string</span> | <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (time <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(time.<span class="title function_">toUTCString</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>in</strong></p>
<p>Javascript 有一个运算符，用于确定对象是否具有带名称的属性：in 运算符，如果指定的属性在指定的对象或其原型链中，则 in 运算符返回 true</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. in</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="attr">swimming</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">running</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">animal: Fish | Dog</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;swimming&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    animal.<span class="title function_">swimming</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal.<span class="title function_">running</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fish</span>: <span class="title class_">Fish</span> = &#123;</span><br><span class="line">  <span class="title function_">swimming</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;swimming&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="七、TypeScript-函数详解"><a href="#七、TypeScript-函数详解" class="headerlink" title="七、TypeScript 函数详解"></a>七、TypeScript 函数详解</h2><p>在 JavaScript 开发中，函数是重要的组成部分，并且函数可以作为一等公民（可以作为参数，也可以作为返回值进 行传递）。<br>那么在使用函数的过程中，函数是否也可以有自己的类型呢？<br>我们可以编写函数类型的表达式（Function Type Expressions），来表示函数类型；</p>
<h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 函数作为参数时，在参数中如何编写类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooFnType</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn: FooFnType</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bar(foo)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义常量时，编写函数的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">AddFnType</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">50</span>, <span class="number">50</span>));</span><br></pre></td></tr></table></figure>

<h3 id="参数的可选类型"><a href="#参数的可选类型" class="headerlink" title="参数的可选类型"></a>参数的可选类型</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选类型必须是写在必选类型后面</span></span><br><span class="line"><span class="comment">// y -&gt; undefined | number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><p>从 ES6 开始，JavaScript 是支持默认参数的，TypeScript 也是支持默认参数的</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必传参数 - 有默认值的参数 - 可选参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = <span class="number">20</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">66</span>);</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<h3 id="函数的剩余参数"><a href="#函数的剩余参数" class="headerlink" title="函数的剩余参数"></a>函数的剩余参数</h3><p>从 ES6 开始，JavaScript 也支持剩余参数，剩余参数语法允许我们将一个不定数量的参数放到一个数组中。</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    total += num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>

<h3 id="指定-this-的类型"><a href="#指定-this-的类型" class="headerlink" title="指定 this 的类型"></a>指定 this 的类型</h3><p><strong>this 的默认推导</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this是可以被推导出来 info对象(TypeScript推导出来)</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ltt&quot;</span>,</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;eating&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">info.<span class="title function_">eating</span>();</span><br></pre></td></tr></table></figure>

<p><strong>this 不明确类型</strong>、</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ThisType</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eating</span>(<span class="params"><span class="variable language_">this</span>: ThisType, message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  eating,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">info.<span class="title function_">eating</span>(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示绑定</span></span><br><span class="line">eating.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span> &#125;, <span class="string">&quot;呵呵呵&quot;</span>);</span><br><span class="line">eating.<span class="title function_">apply</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;james&quot;</span> &#125;, [<span class="string">&quot;嘿嘿嘿&quot;</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><p>在 TypeScript 中，如果我们编写了一个 add 函数，希望可以对字符串和数字类型进行相加，应该如何编写呢？</p>
<p>我们可能会这样来编写，但是其实是错误的</p>
<p><a href="https://imgtu.com/i/qGDcHH"><img src="https://s1.ax1x.com/2022/03/24/qGDcHH.png" alt="qGDcHH.png"></a><br>那么这个代码应该如何去编写呢？</p>
<ul>
<li>在 TypeScript 中，我们可以去编写不同的重载签名（overload signatures）来表示函数可以以不同的方式进行 调用；</li>
<li>一般是编写两个或者以上的重载签名，再去编写一个通用的函数以及实现；</li>
</ul>
<p><strong>函数的重载 (联合类型)</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过联合类型有两个缺点：</span></span><br><span class="line"><span class="comment"> * 1.进行很多的逻辑判断(类型缩小)</span></span><br><span class="line"><span class="comment"> * 2.返回的类型依然是不确定的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a1: <span class="built_in">string</span> | <span class="built_in">number</span>, a2: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> a1 === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> a2 === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 + a2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数的重载 (函数重载)</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数重载：函数的名字相同，但是参数不相同的几个函数，就是函数的重载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">number</span>; <span class="comment">// 没有函数体</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">string</span>, num2: <span class="built_in">string</span></span>): <span class="built_in">string</span>; <span class="comment">// 没有函数体</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">any</span>, num2: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">add</span>(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title function_">add</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数的重载中，实现体的函数是不能被直接调用的</span></span><br><span class="line"><span class="comment">// const result3 = add(&#123; name: &#x27;giao&#x27; &#125;, &#123; age: 18 &#125;) // Error</span></span><br></pre></td></tr></table></figure>

<h2 id="八、TypeScript-类的使用"><a href="#八、TypeScript-类的使用" class="headerlink" title="八、TypeScript 类的使用"></a>八、TypeScript 类的使用</h2><p>在早期的 JavaScript 开发中（ES5）我们需要通过函数和原型链来实现类和继承，从 ES6 开始，引入了 class 关键字，可以 更加方便的定义和使用类。</p>
<p>TypeScript 作为 JavaScript 的超集，也是支持使用 class 关键字的，并且还可以对类的属性和方法等进行静态类型检测。</p>
<p>实际上在 JavaScript 的开发过程中，我们更加习惯于函数式编程：</p>
<ul>
<li>比如 React 开发中，目前更多使用的函数组件以及结合 Hook 的开发模式；</li>
<li>比如在 Vue3 开发中，目前也更加推崇使用 Composition API；</li>
</ul>
<p>但是在封装某些业务的时候，类具有更强大封装性，所以我们也需要掌握它们。</p>
<h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;eating&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;coder_single&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">age</span>);</span><br><span class="line">p.<span class="title function_">eating</span>();</span><br></pre></td></tr></table></figure>

<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。</p>
<p>我们使用 extends 关键字来实现继承，子类中使用 super 来访问父类。</p>
<p>我们来看一下 Student 类继承自 Person：</p>
<ul>
<li>Student 类可以有自己的属性和方法，并且会继承 Person 的属性和方法；</li>
<li>在构造函数中，我们可以通过 super 来调用父类的构造方法，对父类中的属性进行初始化；</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Person eating&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, sno: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// super 调用父类构造器</span></span><br><span class="line">    <span class="variable language_">super</span>(name, age);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sno</span> = sno;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">studying</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;studying&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类从写方法</span></span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 子类从写方法后还想调用父类方法可以使用super来调用父类方法</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">eating</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Student eating&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;coder_singel&quot;</span>, <span class="number">18</span>, <span class="number">111</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">age</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">sno</span>);</span><br><span class="line">s.<span class="title function_">eating</span>();</span><br></pre></td></tr></table></figure>

<h3 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">action</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">action</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Dog running&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">action</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fish swimming&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// animal: dog/fish</span></span><br><span class="line"><span class="comment">// 多态的目的是为了写出更加具备通用性的代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeActions</span>(<span class="params">animals: Animal[]</span>) &#123;</span><br><span class="line">  animals.<span class="title function_">forEach</span>(<span class="function">(<span class="params">animal</span>) =&gt;</span> &#123;</span><br><span class="line">    animal.<span class="title function_">action</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">makeActions</span>([<span class="keyword">new</span> <span class="title class_">Dog</span>(), <span class="keyword">new</span> <span class="title class_">Fish</span>()]);</span><br></pre></td></tr></table></figure>

<h3 id="成员修饰符"><a href="#成员修饰符" class="headerlink" title="成员修饰符"></a>成员修饰符</h3><p>在 TypeScript 中，类的属性和方法支持三种修饰符： public、private、protected</p>
<ul>
<li><p>public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是 public 的；</p>
</li>
<li><p>private 修饰的是仅在同一类中可见、私有的属性或方法；</p>
</li>
<li><p>protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法；</p>
</li>
</ul>
<p>下面直接颜色三种修饰符的使用：</p>
<p><strong>public</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是public的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;coder-single&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<p><strong>private</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// private 修饰的是仅在同一类中可见、私有的属性或方法；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类方法</span></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setName</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">// console.log(p.name) //Error</span></span><br><span class="line">p.<span class="title function_">getName</span>(); <span class="comment">// coderwhy</span></span><br><span class="line">p.<span class="title function_">setName</span>(<span class="string">&quot;single&quot;</span>);</span><br><span class="line">p.<span class="title function_">getName</span>(); <span class="comment">// single</span></span><br></pre></td></tr></table></figure>

<p><strong>protected</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法；</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;single&quot;</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person&quot;</span>, <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;student&quot;</span>, <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">// console.log(p.name) // Error</span></span><br><span class="line">p.<span class="title function_">getName</span>(); <span class="comment">// ok</span></span><br><span class="line">s.<span class="title function_">getName</span>(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="只读属性-redonly"><a href="#只读属性-redonly" class="headerlink" title="只读属性 redonly"></a>只读属性 redonly</h3><p>如果有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用，那么可以使用 readonly</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readonly 只读属性 不允许外界随意进行修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 只读属性可以在构造器中赋值，赋值之后就不可以修改</span></span><br><span class="line">  <span class="comment">// 2. 只读本身不能进行修改，但是如果它是对象类型，对象中的属性可以修改</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> friend?: <span class="title class_">Person</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, friden?: Person</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friend</span> = friden;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;single&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;kobe&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">friend</span>);</span><br><span class="line"><span class="comment">// p.name = &#x27;aaa&#x27; // 不能修改</span></span><br></pre></td></tr></table></figure>

<h3 id="getters-x2F-setters"><a href="#getters-x2F-setters" class="headerlink" title="getters&#x2F;setters"></a>getters&#x2F;setters</h3><p>在前面一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取(getter)和设置(setter)的过程， 这个时候我们可以使用存取器。</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问器setter/getter</span></span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = newName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;giao&quot;</span>);</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法。<br>在 TypeScript 中通过关键字 static 来定义：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class Person &#123;</span></span><br><span class="line"><span class="comment">//   name: string = &#x27;&#x27;</span></span><br><span class="line"><span class="comment">//   age: number = 18</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const p = new Person();</span></span><br><span class="line"><span class="comment">// p.age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">time</span>: <span class="built_in">string</span> = <span class="string">&quot;20:00&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">attendClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;去上学&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span>.<span class="property">time</span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="title function_">attendClass</span>();</span><br></pre></td></tr></table></figure>

<h3 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类 abstract"></a>抽象类 abstract</h3><p>我们知道，继承是多态使用的前提。</p>
<ul>
<li><p>所以在定义很多通用的调用接口时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。</p>
</li>
<li><p>但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法,，我们可以定义为抽象方法。</p>
</li>
</ul>
<p>什么是 抽象方法? 在 TypeScript 中没有具体实现的方法(没有方法体)，就是抽象方法。</p>
<ul>
<li><p>抽象方法，必须存在于抽象类中；</p>
</li>
<li><p>抽象类是使用 abstract 声明的类；</p>
</li>
</ul>
<p>抽象类有如下的特点：</p>
<ul>
<li>抽象类是不能被实例的话（也就是不能通过 new 创建）</li>
<li>抽象方法必须被子类实现，否则该类必须是一个抽象类；</li>
</ul>
<p><strong>抽象类小案例</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeArea</span>(<span class="params">shape: Area</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> shape.<span class="title function_">getArea</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="comment">// 抽象类是不能被实例化的</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Area</span> &#123;</span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">getArea</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Area</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">radius</span> * <span class="variable language_">this</span>.<span class="property">radius</span> * <span class="number">3.14</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Area</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">width: <span class="built_in">number</span>, height: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> r = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">50</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeArea</span>(r));</span><br><span class="line"><span class="comment">// 如果我们传入抽象类会报错</span></span><br><span class="line"><span class="comment">// console.log(makeArea(new Area()))</span></span><br></pre></td></tr></table></figure>

<h3 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h3><p>类本身也可以作为一种数据类型的</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;single&quot;</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;giao&quot;</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="九、TypeScript-接口的使用"><a href="#九、TypeScript-接口的使用" class="headerlink" title="九、TypeScript 接口的使用"></a>九、TypeScript 接口的使用</h2><h3 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过类型(type)别名来声明对象类型</span></span><br><span class="line"><span class="comment">// type InfoType = &#123;name:string,age:number&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种方式声明对象类型：接口interface</span></span><br><span class="line"><span class="comment">// 也可以定义可选类型</span></span><br><span class="line"><span class="comment">// 也可以定义只读属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IInfoType</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选类型-1"><a href="#可选类型-1" class="headerlink" title="可选类型"></a>可选类型</h3><p>接口中也可以定义可选类型</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IInfoType</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  friend?: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="只读类型"><a href="#只读类型" class="headerlink" title="只读类型"></a>只读类型</h3><p>接口中也可以定义只读属性：</p>
<p>这样就意味着我们再初始化之后，这个值是不可以被修改的；</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IInfoType</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type IndexLanguage = &#123;</span></span><br><span class="line"><span class="comment">//   [index: number]: string</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IndexLanguage</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FrontLanguage</span>: <span class="title class_">IndexLanguage</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;HTML&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;CSS&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&quot;Vue&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>前面我们都是通过 interface 来定义对象中普通的属性和方法的，实际上它也可以用来定义函数类型：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ISumType</span> &#123;</span><br><span class="line">  (<span class="attr">n1</span>: <span class="built_in">number</span>, <span class="attr">n2</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sum</span>: <span class="title class_">ISumType</span> = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">40</span>, <span class="number">33</span>));</span><br></pre></td></tr></table></figure>

<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>接口和类一样是可以进行继承的，也是使用 extends 关键字：</p>
<p>并且接口是支持多继承的（类不支持多继承）</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">eating</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">sno</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">studying</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">stu</span>: <span class="title class_">Student</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;single&quot;</span>,</span><br><span class="line">  <span class="attr">sno</span>: <span class="number">118</span>,</span><br><span class="line">  <span class="title function_">eating</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">studying</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><h3 id="interface-和-type-的区别"><a href="#interface-和-type-的区别" class="headerlink" title="interface 和 type 的区别"></a>interface 和 type 的区别</h3>]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>css实现漂亮的弧形</title>
    <url>/2022/03/25/css%E5%AE%9E%E7%8E%B0%E6%BC%82%E4%BA%AE%E7%9A%84%E5%BC%A7%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="CSS-实现漂亮的弧形"><a href="#CSS-实现漂亮的弧形" class="headerlink" title="CSS 实现漂亮的弧形"></a>CSS 实现漂亮的弧形</h1><p><strong>HTMl 如下</strong>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>CSS 如下：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.d1&#123; width: 100%; height: 100px; position: relative; overflow: hidden; &#125;</span><br><span class="line">.d1::after&#123; content: &quot;&quot;; width: 140%; height: 100px; position:absolute; left:</span><br><span class="line">-20%; top: 0; background-color: rgb(44, 111, 199); z-index: -1; border-radius: 0</span><br><span class="line">0 50% 50%; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现效果如下：</strong><br><a href="https://imgtu.com/i/qtCrh8"><img src="https://s1.ax1x.com/2022/03/25/qtCrh8.png" alt="qtCrh8.png"></a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>使用vue3的Teleport组件实现bilibili视频穿梭功能</title>
    <url>/2022/04/14/%E4%BD%BF%E7%94%A8vue3%E7%9A%84Teleport%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0bilibili%E8%A7%86%E9%A2%91%E7%A9%BF%E6%A2%AD%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="使用-vue3-的-Teleport-组件实现-bilibili-视频穿梭功能"><a href="#使用-vue3-的-Teleport-组件实现-bilibili-视频穿梭功能" class="headerlink" title="使用 vue3 的 Teleport 组件实现 bilibili 视频穿梭功能"></a>使用 vue3 的 Teleport 组件实现 bilibili 视频穿梭功能</h1><h3 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h3><p><img src="https://s1.ax1x.com/2022/04/14/LljFfg.gif" alt="LljFfg.gif"></p>
<h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><p><strong>西瓜视频播放器</strong></p>
<p><code>npm install xgplayer</code></p>
<p>网址 <code>https://v2.h5player.bytedance.com/</code></p>
<p><strong>vueUse</strong></p>
<p>VueUse 是一组基于 Composition API 的实用函数</p>
<p><code>npm i @vueuse/core</code></p>
<h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 小视频的播放窗口 --&gt;</span><br><span class="line">  &lt;div class=&quot;player-small&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 被监听出入视口的站位元素 --&gt;</span><br><span class="line">  &lt;div class=&quot;video-container&quot; ref=&quot;videoContainerRef&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;!-- 大的视频播放窗口 --&gt;</span><br><span class="line">  &lt;div class=&quot;player-big&quot;&gt;</span><br><span class="line">    &lt;Teleport to=&quot;.player-small&quot; :disabled=&quot;isVisible&quot;&gt;</span><br><span class="line">      &lt;div id=&quot;mse&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/Teleport&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- 撑出页面滚动的元素 --&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; style=&quot;height: 2000px&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; useIntersectionObserver &#125; from &quot;@vueuse/core&quot;;</span><br><span class="line">import Player from &quot;xgplayer&quot;;</span><br><span class="line">import shaoniangehangMp4 from &quot;@/assets/mp4/shaoniangehang.mp4&quot;;</span><br><span class="line">import shaoniangehangImg from &quot;@/assets/img/shaoniangehang.png&quot;;</span><br><span class="line">// 被监控的元素</span><br><span class="line">const videoContainerRef = ref(null);</span><br><span class="line">// 是否穿梭</span><br><span class="line">const isVisible = ref(true);</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  const dp = new Player(&#123;</span><br><span class="line">    id: &quot;mse&quot;,</span><br><span class="line">    url: shaoniangehangMp4,</span><br><span class="line">    width: &quot;100%&quot;,</span><br><span class="line">    height: &quot;100%&quot;,</span><br><span class="line">    poster: shaoniangehangImg,</span><br><span class="line">  &#125;);</span><br><span class="line">  // 监听站位元素是否在可见区域</span><br><span class="line">  const &#123; stop &#125; = useIntersectionObserver(</span><br><span class="line">    // 被监听的元素</span><br><span class="line">    videoContainerRef.value,</span><br><span class="line">    ([&#123; isIntersecting &#125;]) =&gt; &#123;</span><br><span class="line">      isVisible.value = isIntersecting;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.video-container &#123;</span><br><span class="line">  width: 800px;</span><br><span class="line">  height: 400px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">&#125;</span><br><span class="line">.player-big &#123;</span><br><span class="line">  width: 800px;</span><br><span class="line">  height: 400px;</span><br><span class="line">&#125;</span><br><span class="line">.player-small &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  bottom: 5%;</span><br><span class="line">  right: 3%;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>将svg文件加载为vue组件</title>
    <url>/2022/04/27/%E5%B0%86svg%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%B8%BAvue%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="将-svg-文件加载为-vue-组件"><a href="#将-svg-文件加载为-vue-组件" class="headerlink" title="将 svg 文件加载为 vue 组件"></a>将 svg 文件加载为 vue 组件</h1><p><strong>vite-svg-loader 是一个 vite2.x 社区插件,只支持 vue3,用于将 svg 文件转换成 vue 组件进行使用</strong></p>
<p><strong>基本使用</strong></p>
<p><strong>安装插件</strong></p>
<p><code>npm install vite-svg-loader -D</code></p>
<p><strong>在 vite.config.js 里配置插件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> svgLoader <span class="keyword">from</span> <span class="string">&quot;vite-svg-loader&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>(), <span class="title function_">svgLoader</span>()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>准备 svg 文件进行引入 svg</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> avatar <span class="keyword">from</span> <span class="string">&quot;@/assets/img/avatar.svg?component&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>和使用组件一样使用 svg</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">avatar</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
</search>
